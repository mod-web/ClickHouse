# ClickHouse Test Speed

## Как активировать проект

Создайте и настройте переменные окружения в соответствии с файлом .env.example в корневой директории, переименовав его в .env.

### Запустите docker-compose:
```
docker-compose up --build
```
## Описание

Для наглядной проверки был поднят небольшой проект с ClickHouse, который создает таблицы products и remainders, заполняет их фейковыми данными (по дефолту в проекте 10 000 000 строк для скорости, в сравнении ниже 100 000 000 строк для наглядности) и производит сравнительный анализ нескольких запросов с DISTINCT и GROUP BY.

Для удобства созданы дубликаты запросов в разном стиле - через подзапросы и CTE (имеют в названии префикс _with_cte). Так как с одной стороны подзапросы - возможно более практичный и оптимизированный вариант, с другой стороны иногда требуется чистота и аккуратность запроса CTE.

## Детали

```
Задача:
Необходимо оптимизировать запрос:

select product_id 
from products 
final join remainders 
final using(product_id) 
where updated=today() 
and date=today()-1
```

Иными словами надо проверить, есть ли остатки за вчера для товаров, обновленных сегодня.

### 1. Подзапросы или CTE
В запросе-примере фильтрация по updated и date применяется после соединения 2-х огромных таблиц. То есть сначала выстраивается join-результат, на который затем навешивается фильтрация. Логичнее сначала отфильтровать обе таблицы (в подзапросах или CTE), а потом уже выстраивать их взаимодействие

### 2. IN вместо JOIN
JOIN заставляет избыточно объединять все строки из обеих таблиц по ключу и строить большой промежуточный результат. В то время как по условию задачи нам необходимо получение только тех project_id, которые присутствуют по заданным условиям также и во второй таблице - это можно реализовать с помощью более дешевой операцией IN. Которая, помимо прочего, еще и берет на себя дедупликацию значений подзапроса (данных второй таблицы)

### 3. DISTINCT / GROUP BY вместо FINAL
FINAL заставляет выполнять виртуальный merge на лету, что может быть очень ресурсоемко. Если бы в задаче требовалось дополнительно получить только свежии версии дубликатов (как отдает final), то можно было бы упростить через обращение по MAX(updated) с последующей фильтрацией HAVING. Но так как требуется только наличие product_id, то достаточно использовать DISTINCT product_id или GROUP BY product_id, чтобы отбросить возможные дубликаты менее затратным методом. В целом GROUP BY считается более эффективным вариантом на больших выборках, но лучше провести анализ для конкретных данных

## Результат
|     **Вид запроса**    | **Результат** |
|------------------------|---------------|
| JOIN & FINAL (example) | ~ 0.010495    | 
| DISTINCT & Subquery    | ~ 0.005621    | 
| ROUP BY & Subquery     | ~ 0.006534    | 
| DISTINCT & CTE         | ~ 0.005901    | 
| GROUP BY & CTE         | ~ 0.005843    | 

Так как тестирование проводилось на синтетическом датасете, приведенные показатели являются ориентировочными. При работе с реальными данными любой запрос необходимо дополнительно проверять и оптимизировать с учетом фактических объемов и параметров.
